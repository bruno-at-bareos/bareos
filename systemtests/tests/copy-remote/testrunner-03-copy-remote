#!/bin/bash
#   BAREOSÂ® - Backup Archiving REcovery Open Sourced
#
#   Copyright (C) 2019-2024 Bareos GmbH & Co. KG
#
#   This program is Free Software; you can redistribute it and/or
#   modify it under the terms of version three of the GNU Affero General Public
#   License as published by the Free Software Foundation and included
#   in the file LICENSE.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#   Affero General Public License for more details.
#
#   You should have received a copy of the GNU Affero General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
#   02110-1301, USA.

# this test will execute a copy on remote storage a first time from Full pool.
# a second time from the Copy pool.
# This remote storage as predefined volumes (created then set to Used to emulate a previous backup)
# they have to be manually pruned, and then mounted.
# this test if the director, source reading sd and writing remote destination can handle the case.

set -e
set -o pipefail
set -u

TestName=03-copy-remote

#shellcheck source=../environment.in
. ./environment

#shellcheck source=../scripts/functions
. "${rscripts}"/functions

# create remote storage archivedir
mkdir -p "${archivedir}-remote"
find "${archivedir}-remote" -mindepth 1 -delete

start_test

# label an set of volumes to put their volstatus to used
cat <<END_OF_DATA >"$tmp/bconcmds_volumes"
@out /dev/null
messages
@out ${tmp}/label_volumes1.out
END_OF_DATA

for V in $(seq -w 0001 0005); do
  cat <<END_OF_DATA >>"${tmp}/bconcmds_volumes"
label volume=RemoteCopy-${V} storage=Remote pool=RemoteCopy
update volume=RemoteCopy-${V} volstatus=Used
END_OF_DATA
done
echo "unmount storage=Remote" >>"${tmp}/bconcmds_volumes"

echo " === Prepare volumes === "
run_bconsole "${tmp}/bconcmds_volumes"
echo " === Volumes prepared === "

cat <<END_OF_DATA >"${tmp}/bconcmds"
@out /dev/null
messages
@out ${tmp}/remote_copy_log.out
run job=copy-remote yes
status director
status client
status storage=Remote
@echo waiting 120s first volume
@sleep 120
END_OF_DATA

echo " === Running copy 1 === "
run_bconsole "${tmp}/bconcmds"
echo "waiting 120s first volume"
sleep 120


# Free up volume by volume to have label request each time and force dir and sd to wait
echo " === Purge volumes and mount for copy 1 === "
for V in $(seq -w 0001 0005); do
  bin/bconsole <<<"@$out /dev/null
messages
@$out $tmp/purge_volumes.out
purge volume=RemoteCopy-${V} yes
reload
mount storage=Remote
"
  wait=$(( 180 + RANDOM % 100))
  echo "Next volume in ${wait}s"
  sleep ${wait}
done

bin/bconsole <<<"@$out /dev/null
messages
"

for V in $(bin/bconsole <<<".api 1
list volumes pool=RemoteCopy
" | awk -F "|" '/RemoteCopy-/ {gsub(" ","",$2); print $2}'); do
  echo "${V}"
done
# update last one
bin/bconsole <<<"update volume=${V} volstatus=Used"

echo " === End copy 1 === "
echo


# # to emulate the customer case we create another bunch of volume in state Used
cat <<END_OF_DATA >"${tmp}/bconcmds_volumes"
@out /dev/null
messages
@out ${tmp}/label_volumes2.out
END_OF_DATA

for V in $(seq -w 0006 0010); do
  cat <<END_OF_DATA >>"${tmp}/bconcmds_volumes"
label volume=RemoteCopy-${V} storage=Remote pool=RemoteCopy
update volume=RemoteCopy-${V} volstatus=Used
END_OF_DATA
done

echo " === Prepare volumes 2 === "
run_bconsole "${tmp}/bconcmds_volumes"
echo " === Volumes prepared 2 === "

echo " === Running copy 2 === "
cat <<END_OF_DATA >"${tmp}/bconcmds2"
@out /dev/null
messages
@out ${tmp}/remote_copy_log2.out
run job=copy-remote pool=Full yes
status director
status client
status storage=Remote
@sleep 10
END_OF_DATA

run_bconsole "${tmp}/bconcmds2"

V=6
while [ "$(bin/bconsole <<<".status dir running" | grep -c '    17')" -ge 1 ]; do
  V=$((V + 1))
  VOL=$(printf "RemoteCopy-%04d" ${V})
  bin/bconsole <<<"purge volume=${VOL} pool=RemoteCopy storage=Remote
reload
mount storage=Remote
"
  sleep $(( 60 + RANDOM % 60))
done

end_test
